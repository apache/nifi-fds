{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","../../../../src/platform/core/chips/chips.component.ts","../../../../src/platform/core/chips/chips.module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","TdChipDirective","templateRef","viewContainerRef","_super","TemplatePortalDirective","Directive","args","selector","TemplateRef","ViewContainerRef","TdAutocompleteOptionDirective","_changeDetectorRef","_TdChipsMixinBase","mixinControlValueAccessor","mixinDisabled","TdChipsBase","TdChipsComponent","_elementRef","_renderer","_document","_this","_outsideClickSubs","Subscription","EMPTY","_inputValueChangesSubs","_isMousedown","_length","_stacked","_requireMatch","_color","_inputPosition","_chipAddition","_chipRemoval","_focused","_required","_tabIndex","_touchendDebounce","_internalClick","_internalActivateOption","inputControl","FormControl","debounce","add","EventEmitter","remove","inputChange","chipFocus","chipBlur","compareWith","o1","o2","addClass","nativeElement","defineProperty","_items","items","_setFirstOptionActive","markForCheck","stacked","coerceBooleanProperty","inputPosition","requireMatch","required","chipAddition","_toggleInput","disabled","chipRemoval","canAddChip","placeholder","color","removeClass","focusListener","event","focus","preventDefault","mousedownListener","timer","toPromise","then","clickListener","clickTarget","className","indexOf","stopPropagation","keydownListener","keyCode","TAB","removeFocusedState","ESCAPE","_inputChild","focused","_nativeInput","blur","_closeAutocomplete","ngOnInit","valueChanges","pipe","debounceTime","subscribe","value","emit","ngAfterViewInit","_watchOutsideClick","ngDoCheck","length","onChange","ngOnDestroy","unsubscribe","_setInternalClick","onDisabledChange","v","_handleAddChip","selectedOptions","_options","toArray","filter","option","active","setInactiveStyles","_autocompleteTrigger","activeOption","trim","addChip","setFocusedState","_openAutocomplete","setValue","findIndex","item","push","removeChip","index","removedValues","splice","_totalChips","_focusChip","_handleChipBlur","_handleChipFocus","_handleFocus","_focusFirstChip","_inputKeydown","UP_ARROW","LEFT_ARROW","DELETE","BACKSPACE","_focusLastChip","RIGHT_ARROW","_chipKeydown","canRemoveChip","DOWN_ARROW","_removeInputDisplay","panelOpen","openPanel","closePanel","_chipsChildren","enable","disable","forEach","setActiveStyles","merge","fromEvent","setTimeout","contains","onTouched","Component","providers","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","multi","inputs","template","changeDetection","ChangeDetectionStrategy","OnPush","ElementRef","Renderer2","Optional","type","Inject","DOCUMENT","ChangeDetectorRef","ViewChild","static","MatInput","MatAutocompleteTrigger","ViewChildren","MatChip","ContentChild","MatOption","Input","Output","HostBinding","HostListener","NgModule","imports","ReactiveFormsModule","CommonModule","MatInputModule","MatIconModule","MatChipsModule","MatAutocompleteModule","declarations","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {\n  Component,\n  Input,\n  Output,\n  forwardRef,\n  DoCheck,\n  ViewChild,\n  ViewChildren,\n  QueryList,\n  OnInit,\n  HostListener,\n  ElementRef,\n  Optional,\n  Inject,\n  Directive,\n  TemplateRef,\n  ViewContainerRef,\n  ContentChild,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  AfterViewInit,\n  OnDestroy,\n  HostBinding,\n  Renderer2,\n} from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { EventEmitter } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, ControlValueAccessor, FormControl } from '@angular/forms';\n\nimport { TemplatePortalDirective } from '@angular/cdk/portal';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport {\n  UP_ARROW,\n  DOWN_ARROW,\n  ESCAPE,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  DELETE,\n  BACKSPACE,\n  ENTER,\n  SPACE,\n  TAB,\n  HOME,\n} from '@angular/cdk/keycodes';\nimport { MatChip } from '@angular/material/chips';\nimport { MatInput } from '@angular/material/input';\nimport { MatOption } from '@angular/material/core';\nimport { MatAutocompleteTrigger } from '@angular/material/autocomplete';\n\nimport { Observable, Subscription, timer, merge, fromEvent } from 'rxjs';\nimport { filter, debounceTime } from 'rxjs/operators';\n\nimport { ICanDisable, mixinDisabled, IControlValueAccessor, mixinControlValueAccessor } from '@covalent/core/common';\n\n@Directive({\n  selector: '[td-chip]ng-template',\n})\nexport class TdChipDirective extends TemplatePortalDirective {\n  constructor(templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef) {\n    super(templateRef, viewContainerRef);\n  }\n}\n\n@Directive({\n  selector: '[td-autocomplete-option]ng-template',\n})\nexport class TdAutocompleteOptionDirective extends TemplatePortalDirective {\n  constructor(templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef) {\n    super(templateRef, viewContainerRef);\n  }\n}\n\nexport class TdChipsBase {\n  constructor(public _changeDetectorRef: ChangeDetectorRef) {}\n}\n\n/* tslint:disable-next-line */\nexport const _TdChipsMixinBase = mixinControlValueAccessor(mixinDisabled(TdChipsBase), []);\n\n@Component({\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => TdChipsComponent),\n      multi: true,\n    },\n  ],\n  selector: 'td-chips',\n  inputs: ['disabled', 'value'],\n  styleUrls: ['./chips.component.scss'],\n  templateUrl: './chips.component.html',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class TdChipsComponent\n  extends _TdChipsMixinBase\n  implements IControlValueAccessor, DoCheck, OnInit, AfterViewInit, OnDestroy, ICanDisable\n{\n  private _outsideClickSubs: Subscription = Subscription.EMPTY;\n  private _inputValueChangesSubs: Subscription = Subscription.EMPTY;\n  private _isMousedown: boolean = false;\n\n  private _items: any[];\n  private _length: number = 0;\n  private _stacked: boolean = false;\n  private _requireMatch: boolean = false;\n  private _color: 'primary' | 'accent' | 'warn' = 'primary';\n  private _inputPosition: 'before' | 'after' = 'after';\n  private _chipAddition: boolean = true;\n  private _chipRemoval: boolean = true;\n  private _focused: boolean = false;\n  private _required: boolean = false;\n  private _tabIndex: number = 0;\n  private _touchendDebounce: number = 100;\n\n  _internalClick: boolean = false;\n  _internalActivateOption: boolean = false;\n\n  @ViewChild('input', { static: true }) _nativeInput: ElementRef;\n  @ViewChild(MatInput, { static: true }) _inputChild: MatInput;\n  @ViewChild(MatAutocompleteTrigger, { static: true }) _autocompleteTrigger: MatAutocompleteTrigger;\n  @ViewChildren(MatChip) _chipsChildren: QueryList<MatChip>;\n\n  @ContentChild(TdChipDirective) _chipTemplate: TdChipDirective;\n  @ContentChild(TdAutocompleteOptionDirective)\n  _autocompleteOptionTemplate: TdAutocompleteOptionDirective;\n\n  @ViewChildren(MatOption) _options: QueryList<MatOption>;\n\n  /**\n   * Flag that is true when autocomplete is focused.\n   */\n  get focused(): boolean {\n    return this._focused;\n  }\n\n  /**\n   * FormControl for the matInput element.\n   */\n  inputControl: FormControl = new FormControl();\n\n  /**\n   * items?: any[]\n   * Renders the `mat-autocomplete` with the provided list to display as options.\n   */\n  @Input('items')\n  set items(items: any[]) {\n    this._items = items;\n    this._setFirstOptionActive();\n    this._changeDetectorRef.markForCheck();\n  }\n  get items(): any[] {\n    return this._items;\n  }\n\n  /**\n   * stacked?: boolean\n   * Set stacked or horizontal chips depending on value.\n   * Defaults to false.\n   */\n  @Input('stacked')\n  set stacked(stacked: boolean) {\n    this._stacked = coerceBooleanProperty(stacked);\n  }\n  get stacked(): boolean {\n    return this._stacked;\n  }\n\n  /**\n   * inputPosition?: 'before' | 'after'\n   * Set input position before or after the chips.\n   * Defaults to 'after'.\n   */\n  @Input('inputPosition')\n  set inputPosition(inputPosition: 'before' | 'after') {\n    this._inputPosition = inputPosition;\n  }\n  get inputPosition(): 'before' | 'after' {\n    return this._inputPosition;\n  }\n\n  /**\n   * requireMatch?: boolean\n   * Blocks custom inputs and only allows selections from the autocomplete list.\n   */\n  @Input('requireMatch')\n  set requireMatch(requireMatch: boolean) {\n    this._requireMatch = coerceBooleanProperty(requireMatch);\n  }\n  get requireMatch(): boolean {\n    return this._requireMatch;\n  }\n\n  /**\n   * required?: boolean\n   * Value is set to true if at least one chip is needed\n   * Defaults to false\n   */\n  @Input('required')\n  set required(required: boolean) {\n    this._required = coerceBooleanProperty(required);\n  }\n  get required(): boolean {\n    return this._required;\n  }\n\n  /**\n   * chipAddition?: boolean\n   * Disables the ability to add chips. When setting disabled as true, this will be overriden.\n   * Defaults to true.\n   */\n  @Input('chipAddition')\n  set chipAddition(chipAddition: boolean) {\n    this._chipAddition = chipAddition;\n    this._toggleInput();\n  }\n  get chipAddition(): boolean {\n    return this._chipAddition;\n  }\n\n  /**\n   * Checks if not in disabled state and if chipAddition is set to 'true'\n   * States if a chip can be added and if the input is available\n   */\n  get canAddChip(): boolean {\n    return this.chipAddition && !this.disabled;\n  }\n\n  /**\n   * chipRemoval?: boolean\n   * Disables the ability to remove chips. If it doesn't exist chip remmoval defaults to true.\n   * When setting disabled as true, this will be overriden to false.\n   */\n  @Input('chipRemoval')\n  set chipRemoval(chipRemoval: boolean) {\n    this._chipRemoval = chipRemoval;\n  }\n  get chipRemoval(): boolean {\n    return this._chipRemoval;\n  }\n\n  /**\n   * Checks if not in disabled state and if chipRemoval is set to 'true'\n   * States if a chip can be removed\n   */\n  get canRemoveChip(): boolean {\n    return this.chipRemoval && !this.disabled;\n  }\n\n  /**\n   * returns the display placeholder\n   */\n  get displayPlaceHolder(): string {\n    if (!this.canAddChip) {\n      return '';\n    }\n    return this._required ? `${this.placeholder} *` : this.placeholder;\n  }\n\n  /**\n   * placeholder?: string\n   * Placeholder for the autocomplete input.\n   */\n  @Input() placeholder: string;\n\n  /**\n   * debounce?: number\n   * Debounce timeout between keypresses. Defaults to 200.\n   */\n  @Input() debounce: number = 200;\n\n  /**\n   * color?: 'primary' | 'accent' | 'warn'\n   * Sets the color for the input and focus/selected state of the chips.\n   * Defaults to 'primary'\n   */\n  @Input('color')\n  set color(color: 'primary' | 'accent' | 'warn') {\n    if (color) {\n      this._renderer.removeClass(this._elementRef.nativeElement, 'mat-' + this._color);\n      this._color = color;\n      this._renderer.addClass(this._elementRef.nativeElement, 'mat-' + this._color);\n    }\n  }\n  get color(): 'primary' | 'accent' | 'warn' {\n    return this._color;\n  }\n\n  /**\n   * add?: function\n   * Method to be executed when a chip is added.\n   * Sends chip value as event.\n   */\n  @Output() add: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * remove?: function\n   * Method to be executed when a chip is removed.\n   * Sends chip value as event.\n   */\n  @Output() remove: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * inputChange?: function\n   * Method to be executed when the value in the autocomplete input changes.\n   * Sends string value as event.\n   */\n  @Output() inputChange: EventEmitter<string> = new EventEmitter<string>();\n\n  /**\n   * chipFocus?: function\n   * Method to be executed when a chip is focused.\n   * Sends chip value as event.\n   */\n  @Output() chipFocus: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * blur?: function\n   * Method to be executed when a chip is blurred.\n   * Sends chip value as event.\n   */\n  @Output() chipBlur: EventEmitter<any> = new EventEmitter<any>();\n\n  /**\n   * Hostbinding to set the a11y of the TdChipsComponent depending on its state\n   */\n  @HostBinding('attr.tabindex')\n  get tabIndex(): number {\n    return this.disabled ? -1 : this._tabIndex;\n  }\n\n  constructor(\n    private _elementRef: ElementRef,\n    private _renderer: Renderer2,\n    @Optional() @Inject(DOCUMENT) private _document: any,\n    _changeDetectorRef: ChangeDetectorRef,\n  ) {\n    super(_changeDetectorRef);\n    this._renderer.addClass(this._elementRef.nativeElement, 'mat-' + this._color);\n  }\n\n  /**\n   * compareWith? function\n   * Function used to check whether a chip value already exists.\n   * Defaults to strict equality comparison ===\n   */\n  @Input() compareWith: (o1: any, o2: any) => boolean = (o1: any, o2: any) => {\n    return o1 === o2;\n  };\n\n  /**\n   * Listens to host focus event to act on it\n   */\n  @HostListener('focus', ['$event'])\n  focusListener(event: FocusEvent): void {\n    // should only focus if its not via mousedown to prevent clashing with autocomplete\n    if (!this._isMousedown) {\n      this.focus();\n    }\n    event.preventDefault();\n  }\n\n  /**\n   * Listens to host mousedown event to act on it\n   */\n  @HostListener('mousedown', ['$event'])\n  mousedownListener(event: FocusEvent): void {\n    // sets a flag to know if there was a mousedown and then it returns it back to false\n    this._isMousedown = true;\n    timer()\n      .toPromise()\n      .then(() => {\n        this._isMousedown = false;\n      });\n  }\n\n  /**\n   * If clicking on :host or `td-chips-wrapper`, then we stop the click propagation so the autocomplete\n   * doesnt close automatically.\n   */\n  @HostListener('click', ['$event'])\n  clickListener(event: Event): void {\n    const clickTarget: HTMLElement = <HTMLElement>event.target;\n    if (clickTarget === this._elementRef.nativeElement || clickTarget.className.indexOf('td-chips-wrapper') > -1) {\n      this.focus();\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Listens to host keydown event to act on it depending on the keypress\n   */\n  @HostListener('keydown', ['$event'])\n  keydownListener(event: KeyboardEvent): void {\n    switch (event.keyCode) {\n      case TAB:\n        // if tabing out, then unfocus the component\n        timer()\n          .toPromise()\n          .then(() => {\n            this.removeFocusedState();\n          });\n        break;\n      case ESCAPE:\n        if (this._inputChild.focused) {\n          this._nativeInput.nativeElement.blur();\n          this.removeFocusedState();\n          this._closeAutocomplete();\n        } else {\n          this.focus();\n        }\n        break;\n      default:\n      // default\n    }\n  }\n\n  ngOnInit(): void {\n    this._inputValueChangesSubs = this.inputControl.valueChanges\n      .pipe(debounceTime(this.debounce))\n      .subscribe((value: string) => {\n        this.inputChange.emit(value ? value : '');\n      });\n    this._changeDetectorRef.markForCheck();\n  }\n\n  ngAfterViewInit(): void {\n    this._watchOutsideClick();\n    this._changeDetectorRef.markForCheck();\n  }\n\n  ngDoCheck(): void {\n    // Throw onChange event only if array changes size.\n    if (this.value && this.value.length !== this._length) {\n      this._length = this.value.length;\n      this.onChange(this.value);\n    }\n  }\n\n  ngOnDestroy(): void {\n    this._outsideClickSubs.unsubscribe();\n    this._inputValueChangesSubs.unsubscribe();\n  }\n\n  _setInternalClick(): void {\n    this._internalClick = true;\n  }\n\n  /** Method executed when the disabled value changes */\n  onDisabledChange(v: boolean): void {\n    this._toggleInput();\n  }\n\n  /**\n   * Method that is executed when trying to create a new chip from the autocomplete.\n   * It check if [requireMatch] is enabled, and tries to add the first active option\n   * else if just adds the value thats on the input\n   * returns 'true' if successful, 'false' if it fails.\n   */\n  _handleAddChip(): boolean {\n    let value: any;\n    if (this.requireMatch) {\n      const selectedOptions: MatOption[] = this._options.toArray().filter((option: MatOption) => {\n        return option.active;\n      });\n      if (selectedOptions.length > 0) {\n        value = selectedOptions[0].value;\n        selectedOptions[0].setInactiveStyles();\n      }\n      if (!value) {\n        return false;\n      }\n    } else {\n      // if there is a selection, then use that\n      // else use the input value as chip\n      if (this._autocompleteTrigger.activeOption) {\n        value = this._autocompleteTrigger.activeOption.value;\n        this._autocompleteTrigger.activeOption.setInactiveStyles();\n      } else {\n        value = this._inputChild.value;\n        if (value.trim() === '') {\n          return false;\n        }\n      }\n    }\n    return this.addChip(value);\n  }\n\n  /**\n   * Method thats exectuted when trying to add a value as chip\n   * returns 'true' if successful, 'false' if it fails.\n   */\n  addChip(value: any): boolean {\n    /**\n     * add a debounce ms delay when reopening the autocomplete to give it time\n     * to rerender the next list and at the correct spot\n     */\n\n    this._closeAutocomplete();\n    timer(this.debounce)\n      .toPromise()\n      .then(() => {\n        this.setFocusedState();\n        this._setFirstOptionActive();\n        this._openAutocomplete();\n      });\n\n    this.inputControl.setValue('');\n    // check if value is already part of the model\n    if (this.value.findIndex((item: any) => this.compareWith(item, value)) > -1) {\n      return false;\n    }\n\n    this.value.push(value);\n    this.add.emit(value);\n    this.onChange(this.value);\n    this._changeDetectorRef.markForCheck();\n    return true;\n  }\n\n  /**\n   * Method that is executed when trying to remove a chip.\n   * returns 'true' if successful, 'false' if it fails.\n   */\n  removeChip(index: number): boolean {\n    const removedValues: any[] = this.value.splice(index, 1);\n    if (removedValues.length === 0) {\n      return false;\n    }\n\n    /**\n     * Checks if deleting last single chip, to focus input afterwards\n     * Else check if its not the last chip of the list to focus the next one.\n     */\n    if (index === this._totalChips - 1 && index === 0) {\n      this._inputChild.focus();\n    } else if (index < this._totalChips - 1) {\n      this._focusChip(index + 1);\n    } else if (index > 0) {\n      this._focusChip(index - 1);\n    }\n\n    this.remove.emit(removedValues[0]);\n    this.onChange(this.value);\n    this.inputControl.setValue('');\n    this._changeDetectorRef.markForCheck();\n    return true;\n  }\n\n  /**\n   * Sets blur of chip and sends out event\n   */\n  _handleChipBlur(event: FocusEvent, value: any): void {\n    this.chipBlur.emit(value);\n  }\n\n  /**\n   * Sets focus of chip and sends out event\n   */\n  _handleChipFocus(event: FocusEvent, value: any): void {\n    this.setFocusedState();\n    this.chipFocus.emit(value);\n  }\n\n  _handleFocus(): boolean {\n    this.setFocusedState();\n    this._setFirstOptionActive();\n    return true;\n  }\n\n  /**\n   * Sets focus state of the component\n   */\n  setFocusedState(): void {\n    if (!this.disabled) {\n      this._focused = true;\n      this._tabIndex = -1;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /**\n   * Removes focus state of the component\n   */\n  removeFocusedState(): void {\n    this._focused = false;\n    this._tabIndex = 0;\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Programmatically focus the input or first chip. Since its the component entry point\n   * depending if a user can add or remove chips\n   */\n  focus(): void {\n    if (this.canAddChip) {\n      this._inputChild.focus();\n    } else if (!this.disabled) {\n      this._focusFirstChip();\n    }\n  }\n\n  /**\n   * Passes relevant input key presses.\n   */\n  _inputKeydown(event: KeyboardEvent): void {\n    switch (event.keyCode) {\n      case UP_ARROW:\n        /**\n         * Since the first item is highlighted on [requireMatch], we need to inactivate it\n         * when pressing the up key\n         */\n        if (this.requireMatch) {\n          const length: number = this._options.length;\n          if (length > 1 && this._options.toArray()[0].active && this._internalActivateOption) {\n            this._options.toArray()[0].setInactiveStyles();\n            this._internalActivateOption = false;\n            // prevent default window scrolling\n            event.preventDefault();\n          }\n        }\n        break;\n      case LEFT_ARROW:\n      case DELETE:\n      case BACKSPACE:\n        this._closeAutocomplete();\n        /** Check to see if input is empty when pressing left arrow to move to the last chip */\n        if (!this._inputChild.value) {\n          this._focusLastChip();\n          // prevent default window scrolling\n          event.preventDefault();\n        }\n        break;\n      case RIGHT_ARROW:\n        this._closeAutocomplete();\n        /** Check to see if input is empty when pressing right arrow to move to the first chip */\n        if (!this._inputChild.value) {\n          this._focusFirstChip();\n          // prevent default window scrolling\n          event.preventDefault();\n        }\n        break;\n      default:\n      // default\n    }\n  }\n\n  /**\n   * Passes relevant chip key presses.\n   */\n  _chipKeydown(event: KeyboardEvent, index: number): void {\n    switch (event.keyCode) {\n      case DELETE:\n      case BACKSPACE:\n        /** Check to see if we can delete a chip */\n        if (this.canRemoveChip) {\n          this.removeChip(index);\n        }\n        break;\n      case UP_ARROW:\n      case LEFT_ARROW:\n        /**\n         * Check to see if left/down arrow was pressed while focusing the first chip to focus input next\n         * Also check if input should be focused\n         */\n        if (index === 0) {\n          // only try to target input if pressing left\n          if (this.canAddChip && event.keyCode === LEFT_ARROW) {\n            this._inputChild.focus();\n          } else {\n            this._focusLastChip();\n          }\n        } else if (index > 0) {\n          this._focusChip(index - 1);\n        }\n        // prevent default window scrolling\n        event.preventDefault();\n        break;\n      case DOWN_ARROW:\n      case RIGHT_ARROW:\n        /**\n         * Check to see if right/up arrow was pressed while focusing the last chip to focus input next\n         * Also check if input should be focused\n         */\n        if (index === this._totalChips - 1) {\n          // only try to target input if pressing right\n          if (this.canAddChip && event.keyCode === RIGHT_ARROW) {\n            this._inputChild.focus();\n          } else {\n            this._focusFirstChip();\n          }\n        } else if (index < this._totalChips - 1) {\n          this._focusChip(index + 1);\n        }\n        // prevent default window scrolling\n        event.preventDefault();\n        break;\n      default:\n      // default\n    }\n  }\n\n  /**\n   * Method to remove from display the value added from the autocomplete since it goes directly as chip.\n   */\n  _removeInputDisplay(): string {\n    return '';\n  }\n\n  /**\n   * Method to open the autocomplete manually if its not already opened\n   */\n  _openAutocomplete(): void {\n    if (!this._autocompleteTrigger.panelOpen) {\n      this._autocompleteTrigger.openPanel();\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /**\n   * Method to close the autocomplete manually if its not already closed\n   */\n  _closeAutocomplete(): void {\n    if (this._autocompleteTrigger.panelOpen) {\n      this._autocompleteTrigger.closePanel();\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /**\n   * Get total of chips\n   */\n  get _totalChips(): number {\n    const chips: MatChip[] = this._chipsChildren.toArray();\n    return chips.length;\n  }\n\n  /**\n   * Method to focus a desired chip by index\n   */\n  private _focusChip(index: number): void {\n    /** check to see if index exists in the array before focusing */\n    if (index > -1 && this._totalChips > index) {\n      this._chipsChildren.toArray()[index].focus();\n    }\n  }\n\n  /** Method to focus first chip */\n  private _focusFirstChip(): void {\n    this._focusChip(0);\n  }\n\n  /** Method to focus last chip */\n  private _focusLastChip(): void {\n    this._focusChip(this._totalChips - 1);\n  }\n\n  /**\n   * Method to toggle the disable state of input\n   * Checks if not in disabled state and if chipAddition is set to 'true'\n   */\n  private _toggleInput(): void {\n    if (this.canAddChip) {\n      this.inputControl.enable();\n    } else {\n      this.inputControl.disable();\n    }\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Sets first option as active to let the user know which one will be added when pressing enter\n   * Only if [requireMatch] has been set\n   */\n  private _setFirstOptionActive(): void {\n    if (this.requireMatch) {\n      // need to use a timer here to wait until the autocomplete has been opened (end of queue)\n      timer()\n        .toPromise()\n        .then(() => {\n          if (this.focused && this._options && this._options.length > 0) {\n            // clean up of previously active options\n            this._options.toArray().forEach((option: MatOption) => {\n              option.setInactiveStyles();\n            });\n            // set the first one as active\n            this._options.toArray()[0].setActiveStyles();\n            this._internalActivateOption = true;\n            this._changeDetectorRef.markForCheck();\n          }\n        });\n    }\n  }\n\n  /**\n   * Watches clicks outside of the component to remove the focus\n   * The autocomplete panel is considered inside the component so we\n   * need to use a flag to find out when its clicked.\n   */\n  private _watchOutsideClick(): void {\n    if (this._document) {\n      this._outsideClickSubs = merge(fromEvent(this._document, 'click'), fromEvent(this._document, 'touchend'))\n        .pipe(\n          debounceTime(this._touchendDebounce),\n          filter((event: MouseEvent) => {\n            const clickTarget: HTMLElement = <HTMLElement>event.target;\n            setTimeout(() => {\n              this._internalClick = false;\n            });\n            return (\n              this.focused &&\n              clickTarget !== this._elementRef.nativeElement &&\n              !this._elementRef.nativeElement.contains(clickTarget) &&\n              !this._internalClick\n            );\n          }),\n        )\n        .subscribe(() => {\n          if (this.focused) {\n            this._autocompleteTrigger.closePanel();\n            this.removeFocusedState();\n            this.onTouched();\n            this._changeDetectorRef.markForCheck();\n          }\n        });\n    }\n    return undefined;\n  }\n}\n","import { NgModule } from '@angular/core';\n\nimport { ReactiveFormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n\nimport { MatInputModule } from '@angular/material/input';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatAutocompleteModule } from '@angular/material/autocomplete';\nimport { MatChipsModule } from '@angular/material/chips';\n\nimport { TdChipsComponent, TdChipDirective, TdAutocompleteOptionDirective } from './chips.component';\n\n@NgModule({\n  imports: [ReactiveFormsModule, CommonModule, MatInputModule, MatIconModule, MatChipsModule, MatAutocompleteModule],\n  declarations: [TdChipsComponent, TdChipDirective, TdAutocompleteOptionDirective],\n  exports: [TdChipsComponent, TdChipDirective, TdAutocompleteOptionDirective],\n})\nexport class CovalentChipsModule {}\n"]}