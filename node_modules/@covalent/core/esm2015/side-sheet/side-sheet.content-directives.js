/**
 * @fileoverview added by tsickle
 * Generated from: side-sheet.content-directives.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable */
import { Directive, Input, Optional, ElementRef } from '@angular/core';
import { CovalentSideSheet } from './side-sheet';
import { _closeSideSheetVia, CovalentSideSheetRef } from './side-sheet-ref';
/**
 * Counter used to generate unique IDs for dialog elements.
 * @type {?}
 */
let dialogElementUid = 0;
/**
 * Button that will close the current dialog.
 */
export class CovalentSideSheetClose {
    /**
     * @param {?} dialogRef
     * @param {?} _elementRef
     * @param {?} _dialog
     */
    constructor(dialogRef, _elementRef, _dialog) {
        this.dialogRef = dialogRef;
        this._elementRef = _elementRef;
        this._dialog = _dialog;
        /**
         * Default to "button" to prevents accidental form submits.
         */
        this.type = 'button';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.dialogRef) {
            // When this directive is included in a dialog via TemplateRef (rather than being
            // in a Component), the DialogRef isn't available via injection because embedded
            // views cannot be given a custom injector. Instead, we look up the DialogRef by
            // ID. This must occur in `onInit`, as the ID binding for the dialog container won't
            // be resolved at constructor time.
            this.dialogRef = (/** @type {?} */ (getClosestDialog(this._elementRef, this._dialog.openSideSheets)));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const proxiedChange = changes['_CovalentSideSheetClose'] || changes['_CovalentSideSheetCloseResult'];
        if (proxiedChange) {
            this.dialogResult = proxiedChange.currentValue;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _onButtonClick(event) {
        // Determinate the focus origin using the click event, because using the FocusMonitor will
        // result in incorrect origins. Most of the time, close buttons will be auto focused in the
        // dialog, and therefore clicking the button won't result in a focus change. This means that
        // the FocusMonitor won't detect any origin change, and will always output `program`.
        _closeSideSheetVia(this.dialogRef, event.screenX === 0 && event.screenY === 0 ? 'keyboard' : 'mouse', this.dialogResult);
    }
}
CovalentSideSheetClose.decorators = [
    { type: Directive, args: [{
                selector: '[td-side-sheet-close], [CovalentSideSheetClose]',
                exportAs: 'CovalentSideSheetClose',
                host: {
                    '(click)': '_onButtonClick($event)',
                    '[attr.aria-label]': 'ariaLabel || null',
                    '[attr.type]': 'type',
                },
            },] }
];
/** @nocollapse */
CovalentSideSheetClose.ctorParameters = () => [
    { type: CovalentSideSheetRef, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: CovalentSideSheet }
];
CovalentSideSheetClose.propDecorators = {
    ariaLabel: [{ type: Input, args: ['aria-label',] }],
    type: [{ type: Input }],
    dialogResult: [{ type: Input, args: ['td-side-sheet-close',] }],
    _CovalentSideSheetClose: [{ type: Input, args: ['CovalentSideSheetClose',] }]
};
if (false) {
    /**
     * Screenreader label for the button.
     * @type {?}
     */
    CovalentSideSheetClose.prototype.ariaLabel;
    /**
     * Default to "button" to prevents accidental form submits.
     * @type {?}
     */
    CovalentSideSheetClose.prototype.type;
    /**
     * Dialog close input.
     * @type {?}
     */
    CovalentSideSheetClose.prototype.dialogResult;
    /** @type {?} */
    CovalentSideSheetClose.prototype._CovalentSideSheetClose;
    /** @type {?} */
    CovalentSideSheetClose.prototype.dialogRef;
    /**
     * @type {?}
     * @private
     */
    CovalentSideSheetClose.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    CovalentSideSheetClose.prototype._dialog;
}
/**
 * Title of a side sheet element. Stays fixed to the top of the side sheet when scrolling.
 */
export class CovalentSideSheetTitle {
    /**
     * @param {?} _dialogRef
     * @param {?} _elementRef
     * @param {?} _dialog
     */
    constructor(_dialogRef, _elementRef, _dialog) {
        this._dialogRef = _dialogRef;
        this._elementRef = _elementRef;
        this._dialog = _dialog;
        /**
         * Unique id for the dialog title. If none is supplied, it will be auto-generated.
         */
        this.id = `td-side-sheet-title-${dialogElementUid++}`;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dialogRef) {
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const container = this._dialogRef._containerInstance;
                if (container && !container._ariaLabelledBy) {
                    container._ariaLabelledBy = this.id;
                }
            }));
        }
        else {
            this._dialogRef = (/** @type {?} */ (getClosestDialog(this._elementRef, this._dialog.openSideSheets)));
        }
    }
}
CovalentSideSheetTitle.decorators = [
    { type: Directive, args: [{
                selector: '[td-side-sheet-title], [CovalentSideSheetTitle]',
                exportAs: 'CovalentSideSheetTitle',
                host: {
                    'class': 'td-side-sheet-title',
                    '[id]': 'id',
                },
            },] }
];
/** @nocollapse */
CovalentSideSheetTitle.ctorParameters = () => [
    { type: CovalentSideSheetRef, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: CovalentSideSheet }
];
CovalentSideSheetTitle.propDecorators = {
    id: [{ type: Input }]
};
if (false) {
    /**
     * Unique id for the dialog title. If none is supplied, it will be auto-generated.
     * @type {?}
     */
    CovalentSideSheetTitle.prototype.id;
    /**
     * @type {?}
     * @private
     */
    CovalentSideSheetTitle.prototype._dialogRef;
    /**
     * @type {?}
     * @private
     */
    CovalentSideSheetTitle.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    CovalentSideSheetTitle.prototype._dialog;
}
/**
 * Scrollable content container of a dialog.
 */
export class CovalentSideSheetContent {
}
CovalentSideSheetContent.decorators = [
    { type: Directive, args: [{
                selector: `[td-side-sheet-content], td-side-sheet-content, [CovalentSideSheetContent]`,
                host: { class: 'td-side-sheet-content' },
            },] }
];
/**
 * Container for the bottom action buttons in a dialog.
 * Stays fixed to the bottom when scrolling.
 */
export class CovalentSideSheetActions {
}
CovalentSideSheetActions.decorators = [
    { type: Directive, args: [{
                selector: `[td-side-sheet-actions], td-side-sheet-actions, [CovalentSideSheetActions]`,
                host: { class: 'td-side-sheet-actions' },
            },] }
];
/**
 * Container for the wrapper part of the dialog
 */
export class CovalentSideSheetWrapper {
}
CovalentSideSheetWrapper.decorators = [
    { type: Directive, args: [{
                selector: `[td-side-sheet-wrapper], td-side-sheet-wrapper, [CovalentSideSheetWrapper]`,
                host: { class: 'td-side-sheet-wrapper' },
            },] }
];
/**
 * Finds the closest CovalentSideSheetRef to an element by looking at the DOM.
 * @param {?} element Element relative to which to look for a dialog.
 * @param {?} openDialogs References to the currently-open dialogs.
 * @return {?}
 */
function getClosestDialog(element, openDialogs) {
    /** @type {?} */
    let parent = element.nativeElement.parentElement;
    while (parent && !parent.classList.contains('td-side-sheet-container')) {
        parent = parent.parentElement;
    }
    return parent ? openDialogs.find((/**
     * @param {?} dialog
     * @return {?}
     */
    (dialog) => dialog.id === (/** @type {?} */ (parent)).id)) : null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lkZS1zaGVldC5jb250ZW50LWRpcmVjdGl2ZXMuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4vLi4vLi4vc3JjL3BsYXRmb3JtL2NvcmUvc2lkZS1zaGVldC8iLCJzb3VyY2VzIjpbInNpZGUtc2hlZXQuY29udGVudC1kaXJlY3RpdmVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFxQixRQUFRLEVBQWlCLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN6RyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDakQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLG9CQUFvQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7Ozs7O0lBR3hFLGdCQUFnQixHQUFHLENBQUM7Ozs7QUFjeEIsTUFBTSxPQUFPLHNCQUFzQjs7Ozs7O0lBWWpDLFlBQ3FCLFNBQW9DLEVBQy9DLFdBQW9DLEVBQ3BDLE9BQTBCO1FBRmYsY0FBUyxHQUFULFNBQVMsQ0FBMkI7UUFDL0MsZ0JBQVcsR0FBWCxXQUFXLENBQXlCO1FBQ3BDLFlBQU8sR0FBUCxPQUFPLENBQW1COzs7O1FBVjNCLFNBQUksR0FBa0MsUUFBUSxDQUFDO0lBV3JELENBQUM7Ozs7SUFFSixRQUFRO1FBQ04sSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbkIsaUZBQWlGO1lBQ2pGLGdGQUFnRjtZQUNoRixnRkFBZ0Y7WUFDaEYsb0ZBQW9GO1lBQ3BGLG1DQUFtQztZQUNuQyxJQUFJLENBQUMsU0FBUyxHQUFHLG1CQUFBLGdCQUFnQixDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsRUFBQyxDQUFDO1NBQ25GO0lBQ0gsQ0FBQzs7Ozs7SUFFRCxXQUFXLENBQUMsT0FBc0I7O2NBQzFCLGFBQWEsR0FBRyxPQUFPLENBQUMseUJBQXlCLENBQUMsSUFBSSxPQUFPLENBQUMsK0JB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LFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsNEVBQTRFO2dCQUN0RixJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsdUJBQXVCLEVBQUU7YUFDekM7Ozs7O0FBVUQsTUFBTSxPQUFPLHdCQUF3Qjs7O1lBSnBDLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsNEVBQTRFO2dCQUN0RixJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsdUJBQXVCLEVBQUU7YUFDekM7Ozs7Ozs7O0FBUUQsU0FBUyxnQkFBZ0IsQ0FBQyxPQUFnQyxFQUFFLFdBQXdDOztRQUM5RixNQUFNLEdBQXVCLE9BQU8sQ0FBQyxhQUFhLENBQUMsYUFBYTtJQUVwRSxPQUFPLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLHlCQUF5QixDQUFDLEVBQUU7UUFDdEUsTUFBTSxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUM7S0FDL0I7SUFFRCxPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUk7Ozs7SUFBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsS0FBSyxtQkFBQSxNQUFNLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ2hGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkluaXQsIE9wdGlvbmFsLCBTaW1wbGVDaGFuZ2VzLCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb3ZhbGVudFNpZGVTaGVldCB9IGZyb20gJy4vc2lkZS1zaGVldCc7XG5pbXBvcnQgeyBfY2xvc2VTaWRlU2hlZXRWaWEsIENvdmFsZW50U2lkZVNoZWV0UmVmIH0gZnJvbSAnLi9zaWRlLXNoZWV0LXJlZic7XG5cbi8qKiBDb3VudGVyIHVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyBmb3IgZGlhbG9nIGVsZW1lbnRzLiAqL1xubGV0IGRpYWxvZ0VsZW1lbnRVaWQgPSAwO1xuXG4vKipcbiAqIEJ1dHRvbiB0aGF0IHdpbGwgY2xvc2UgdGhlIGN1cnJlbnQgZGlhbG9nLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdGQtc2lkZS1zaGVldC1jbG9zZV0sIFtDb3ZhbGVudFNpZGVTaGVldENsb3NlXScsXG4gIGV4cG9ydEFzOiAnQ292YWxlbnRTaWRlU2hlZXRDbG9zZScsXG4gIGhvc3Q6IHtcbiAgICAnKGNsaWNrKSc6ICdfb25CdXR0b25DbGljaygkZXZlbnQpJyxcbiAgICAnW2F0dHIuYXJpYS1sYWJlbF0nOiAnYXJpYUxhYmVsIHx8IG51bGwnLFxuICAgICdbYXR0ci50eXBlXSc6ICd0eXBlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ292YWxlbnRTaWRlU2hlZXRDbG9zZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgLyoqIFNjcmVlbnJlYWRlciBsYWJlbCBmb3IgdGhlIGJ1dHRvbi4gKi9cbiAgQElucHV0KCdhcmlhLWxhYmVsJykgYXJpYUxhYmVsOiBzdHJpbmc7XG5cbiAgLyoqIERlZmF1bHQgdG8gXCJidXR0b25cIiB0byBwcmV2ZW50cyBhY2NpZGVudGFsIGZvcm0gc3VibWl0cy4gKi9cbiAgQElucHV0KCkgdHlwZTogJ3N1Ym1pdCcgfCAnYnV0dG9uJyB8ICdyZXNldCcgPSAnYnV0dG9uJztcblxuICAvKiogRGlhbG9nIGNsb3NlIGlucHV0LiAqL1xuICBASW5wdXQoJ3RkLXNpZGUtc2hlZXQtY2xvc2UnKSBkaWFsb2dSZXN1bHQ6IGFueTtcblxuICBASW5wdXQoJ0NvdmFsZW50U2lkZVNoZWV0Q2xvc2UnKSBfQ292YWxlbnRTaWRlU2hlZXRDbG9zZTogYW55O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpIHB1YmxpYyBkaWFsb2dSZWY6IENvdmFsZW50U2lkZVNoZWV0UmVmPGFueT4sXG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgcHJpdmF0ZSBfZGlhbG9nOiBDb3ZhbGVudFNpZGVTaGVldCxcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5kaWFsb2dSZWYpIHtcbiAgICAgIC8vIFdoZW4gdGhpcyBkaXJlY3RpdmUgaXMgaW5jbHVkZWQgaW4gYSBkaWFsb2cgdmlhIFRlbXBsYXRlUmVmIChyYXRoZXIgdGhhbiBiZWluZ1xuICAgICAgLy8gaW4gYSBDb21wb25lbnQpLCB0aGUgRGlhbG9nUmVmIGlzbid0IGF2YWlsYWJsZSB2aWEgaW5qZWN0aW9uIGJlY2F1c2UgZW1iZWRkZWRcbiAgICAgIC8vIHZpZXdzIGNhbm5vdCBiZSBnaXZlbiBhIGN1c3RvbSBpbmplY3Rvci4gSW5zdGVhZCwgd2UgbG9vayB1cCB0aGUgRGlhbG9nUmVmIGJ5XG4gICAgICAvLyBJRC4gVGhpcyBtdXN0IG9jY3VyIGluIGBvbkluaXRgLCBhcyB0aGUgSUQgYmluZGluZyBmb3IgdGhlIGRpYWxvZyBjb250YWluZXIgd29uJ3RcbiAgICAgIC8vIGJlIHJlc29sdmVkIGF0IGNvbnN0cnVjdG9yIHRpbWUuXG4gICAgICB0aGlzLmRpYWxvZ1JlZiA9IGdldENsb3Nlc3REaWFsb2codGhpcy5fZWxlbWVudFJlZiwgdGhpcy5fZGlhbG9nLm9wZW5TaWRlU2hlZXRzKSE7XG4gICAgfVxuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGNvbnN0IHByb3hpZWRDaGFuZ2UgPSBjaGFuZ2VzWydfQ292YWxlbnRTaWRlU2hlZXRDbG9zZSddIHx8IGNoYW5nZXNbJ19Db3ZhbGVudFNpZGVTaGVldENsb3NlUmVzdWx0J107XG5cbiAgICBpZiAocHJveGllZENoYW5nZSkge1xuICAgICAgdGhpcy5kaWFsb2dSZXN1bHQgPSBwcm94aWVkQ2hhbmdlLmN1cnJlbnRWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBfb25CdXR0b25DbGljayhldmVudDogTW91c2VFdmVudCkge1xuICAgIC8vIERldGVybWluYXRlIHRoZSBmb2N1cyBvcmlnaW4gdXNpbmcgdGhlIGNsaWNrIGV2ZW50LCBiZWNhdXNlIHVzaW5nIHRoZSBGb2N1c01vbml0b3Igd2lsbFxuICAgIC8vIHJlc3VsdCBpbiBpbmNvcnJlY3Qgb3JpZ2lucy4gTW9zdCBvZiB0aGUgdGltZSwgY2xvc2UgYnV0dG9ucyB3aWxsIGJlIGF1dG8gZm9jdXNlZCBpbiB0aGVcbiAgICAvLyBkaWFsb2csIGFuZCB0aGVyZWZvcmUgY2xpY2tpbmcgdGhlIGJ1dHRvbiB3b24ndCByZXN1bHQgaW4gYSBmb2N1cyBjaGFuZ2UuIFRoaXMgbWVhbnMgdGhhdFxuICAgIC8vIHRoZSBGb2N1c01vbml0b3Igd29uJ3QgZGV0ZWN0IGFueSBvcmlnaW4gY2hhbmdlLCBhbmQgd2lsbCBhbHdheXMgb3V0cHV0IGBwcm9ncmFtYC5cbiAgICBfY2xvc2VTaWRlU2hlZXRWaWEoXG4gICAgICB0aGlzLmRpYWxvZ1JlZixcbiAgICAgIGV2ZW50LnNjcmVlblggPT09IDAgJiYgZXZlbnQuc2NyZWVuWSA9PT0gMCA/ICdrZXlib2FyZCcgOiAnbW91c2UnLFxuICAgICAgdGhpcy5kaWFsb2dSZXN1bHQsXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFRpdGxlIG9mIGEgc2lkZSBzaGVldCBlbGVtZW50LiBTdGF5cyBmaXhlZCB0byB0aGUgdG9wIG9mIHRoZSBzaWRlIHNoZWV0IHdoZW4gc2Nyb2xsaW5nLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdGQtc2lkZS1zaGVldC10aXRsZV0sIFtDb3ZhbGVudFNpZGVTaGVldFRpdGxlXScsXG4gIGV4cG9ydEFzOiAnQ292YWxlbnRTaWRlU2hlZXRUaXRsZScsXG4gIGhvc3Q6IHtcbiAgICAnY2xhc3MnOiAndGQtc2lkZS1zaGVldC10aXRsZScsXG4gICAgJ1tpZF0nOiAnaWQnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDb3ZhbGVudFNpZGVTaGVldFRpdGxlIGltcGxlbWVudHMgT25Jbml0IHtcbiAgLyoqIFVuaXF1ZSBpZCBmb3IgdGhlIGRpYWxvZyB0aXRsZS4gSWYgbm9uZSBpcyBzdXBwbGllZCwgaXQgd2lsbCBiZSBhdXRvLWdlbmVyYXRlZC4gKi9cbiAgQElucHV0KCkgaWQ6IHN0cmluZyA9IGB0ZC1zaWRlLXNoZWV0LXRpdGxlLSR7ZGlhbG9nRWxlbWVudFVpZCsrfWA7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGRpYWxvZyB0aXRsZSBkaXJlY3RpdmUgaXMgYWx3YXlzIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBhIGBDb3ZhbGVudFNpZGVTaGVldFJlZmAuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBsaWdodHdlaWdodC10b2tlbnNcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kaWFsb2dSZWY6IENvdmFsZW50U2lkZVNoZWV0UmVmPGFueT4sXG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgcHJpdmF0ZSBfZGlhbG9nOiBDb3ZhbGVudFNpZGVTaGVldCxcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9kaWFsb2dSZWYpIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9kaWFsb2dSZWYuX2NvbnRhaW5lckluc3RhbmNlO1xuXG4gICAgICAgIGlmIChjb250YWluZXIgJiYgIWNvbnRhaW5lci5fYXJpYUxhYmVsbGVkQnkpIHtcbiAgICAgICAgICBjb250YWluZXIuX2FyaWFMYWJlbGxlZEJ5ID0gdGhpcy5pZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RpYWxvZ1JlZiA9IGdldENsb3Nlc3REaWFsb2codGhpcy5fZWxlbWVudFJlZiwgdGhpcy5fZGlhbG9nLm9wZW5TaWRlU2hlZXRzKSE7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2Nyb2xsYWJsZSBjb250ZW50IGNvbnRhaW5lciBvZiBhIGRpYWxvZy5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiBgW3RkLXNpZGUtc2hlZXQtY29udGVudF0sIHRkLXNpZGUtc2hlZXQtY29udGVudCwgW0NvdmFsZW50U2lkZVNoZWV0Q29udGVudF1gLFxuICBob3N0OiB7IGNsYXNzOiAndGQtc2lkZS1zaGVldC1jb250ZW50JyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDb3ZhbGVudFNpZGVTaGVldENvbnRlbnQge31cblxuLyoqXG4gKiBDb250YWluZXIgZm9yIHRoZSBib3R0b20gYWN0aW9uIGJ1dHRvbnMgaW4gYSBkaWFsb2cuXG4gKiBTdGF5cyBmaXhlZCB0byB0aGUgYm90dG9tIHdoZW4gc2Nyb2xsaW5nLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6IGBbdGQtc2lkZS1zaGVldC1hY3Rpb25zXSwgdGQtc2lkZS1zaGVldC1hY3Rpb25zLCBbQ292YWxlbnRTaWRlU2hlZXRBY3Rpb25zXWAsXG4gIGhvc3Q6IHsgY2xhc3M6ICd0ZC1zaWRlLXNoZWV0LWFjdGlvbnMnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENvdmFsZW50U2lkZVNoZWV0QWN0aW9ucyB7fVxuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgdGhlIHdyYXBwZXIgcGFydCBvZiB0aGUgZGlhbG9nXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogYFt0ZC1zaWRlLXNoZWV0LXdyYXBwZXJdLCB0ZC1zaWRlLXNoZWV0LXdyYXBwZXIsIFtDb3ZhbGVudFNpZGVTaGVldFdyYXBwZXJdYCxcbiAgaG9zdDogeyBjbGFzczogJ3RkLXNpZGUtc2hlZXQtd3JhcHBlcicgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ292YWxlbnRTaWRlU2hlZXRXcmFwcGVyIHt9XG5cbi8qKlxuICogRmluZHMgdGhlIGNsb3Nlc3QgQ292YWxlbnRTaWRlU2hlZXRSZWYgdG8gYW4gZWxlbWVudCBieSBsb29raW5nIGF0IHRoZSBET00uXG4gKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHJlbGF0aXZlIHRvIHdoaWNoIHRvIGxvb2sgZm9yIGEgZGlhbG9nLlxuICogQHBhcmFtIG9wZW5EaWFsb2dzIFJlZmVyZW5jZXMgdG8gdGhlIGN1cnJlbnRseS1vcGVuIGRpYWxvZ3MuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3REaWFsb2coZWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sIG9wZW5EaWFsb2dzOiBDb3ZhbGVudFNpZGVTaGVldFJlZjxhbnk+W10pIHtcbiAgbGV0IHBhcmVudDogSFRNTEVsZW1lbnQgfCBudWxsID0gZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cbiAgd2hpbGUgKHBhcmVudCAmJiAhcGFyZW50LmNsYXNzTGlzdC5jb250YWlucygndGQtc2lkZS1zaGVldC1jb250YWluZXInKSkge1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudCA/IG9wZW5EaWFsb2dzLmZpbmQoKGRpYWxvZykgPT4gZGlhbG9nLmlkID09PSBwYXJlbnQhLmlkKSA6IG51bGw7XG59XG4iXX0=